<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Scooby Snacks Website</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="https://fonts.googleapis.com/css?family=Raleway:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700,700i" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/business-casual.min.css" rel="stylesheet">

  </head>

  <body>

    <h1 class="site-heading text-center text-white d-none d-lg-block">
      <span class="site-heading-upper text-primary mb-3">Scooby Snacks</span>
      <span class="site-heading-lower">The Premier Robotics Team</span>
    </h1>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark py-lg-4" id="mainNav">
      <div class="container">
        <a class="navbar-brand text-uppercase text-expanded font-weight-bold d-lg-none" href="#">Menu</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav mx-auto">
            <li class="nav-item px-lg-4">
              <a class="nav-link text-uppercase text-expanded" href="index.html">Home
                <span class="sr-only">(current)</span>
              </a>
            </li>
            <li class="nav-item px-lg-4">
              <a class="nav-link text-uppercase text-expanded" href="about.html">About</a>
            </li>
            <li class="nav-item px-lg-4">
              <a class="nav-link text-uppercase text-expanded" href="labs.html">Labs</a>
            </li>
            <li class="nav-item active px-lg-4">
              <a class="nav-link text-uppercase text-expanded" href="milestones.html">Milestones</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <section class="page-section cta">
      <div class="container">
        <div class="row">
          <div class="col-xl-9 mx-auto">
            <div class="cta-inner text-center rounded">
              <h2 class="section-heading mb-5">
                <span class="section-heading-upper">Lab Report 2</span>
              </h2>
              <p> <i>David Pirogovsky, Dylan Neal, Jared Gallina, Larry Tang</i> </p>
              <div id = "content" align = "left">
                <p> <b> <big>Intro:</big></b> </p>
                <p>The goal of this lab was to create a treasure detection method by using a camera with an FPGA to determine the presence, shape, and color of treasures. These determined results were then to be processed by the Arduino to relay the presence of a treasure and information about it.</p>
                <p> <b> <big>FPGA Work</big></b> </p>
                <p> <b> Phase Locked Loop:</b></p>
                <p> The first necessary step in this lab was to create a phase-locked loop to generate a 50 MHz clock for the RAM, a 25 MHz clock for the VGA, and a 24 MHz clock for the camera. This was done following the instructions on the lab handout, and found in Quartus in Tools > IP Catalog. </p>
                 <p> <b> Displaying an M9K Block:</b></p>
                <p>In order to display these blocks on the screen, we used a large if-else block with three vertical checks and eight horizontal checks, since there are three color options and two of the colors have eight settings. The first row increments the value of the red color by one as the x value grows, the second row increments the red and green colors together, and the last row increments red and green together, and increments the blue color every other block. </p>
                
                <div align = "middle"><img  src="img/m9kBlock.png" alt=""></div>
                <div align = "middle"><p><small><i>M9K Block Displayed on Screen</i></small></p></div>
                
                <p> <b>Color Bar and Live Camera:</b></p>
                <p> The camera sends the information for a pixel in two bytes in two clock cycles, so we first read both bytes, then sent the data into the downsampler using a data valid bit. The downsampler sets the write enable for the M9K block so that only valid, downsampled data is written, and the HREF line coming out of the camera is used to synchronize the x address of the pixels and when to increment the y address.  The y address is only incremented when the HREF signal marks the end of a row of pixels, and the x address is incremented every 2 PCLK cycles and is reset at the end of each row.  VSYNC is used to reset both x address and y address at the end of an image frame.  </p>
                
                <div align = "middle"><img  src="img/colorBar.png" alt=""></div>
                <div align = "middle"><p><small><i>Color Bar Displayed on Screen</i></small></p></div>
                
                <p> <b>Treasure Detection:</b></p>
                <p> The image processor takes in one pixel at a time and determines what the primary color component of that pixel is, and if the primary color component is greater than a set threshold, it will increment a counter for that color. At VSYNC, the counters will be evaluated, and if one color predominates and is greater than a hardcoded threshold, the result will be set to a value corresponding to a color. Using ternary operators, we output on two pins if the color is red or blue and if a treasure is detected or not. Unfortunately, our image processor incorrectly detects treasure, periodically (watch video above). It is much better at detecting colors when there is an actual treasure present, as the GPIO pin is more consistently high with the red treasure in front of the camera. Team arduino will have to use some correction method to correctly detect treasures. </p>
                
                <p> <b> <big>Arduino:</big></b> </p>
                <p> <b>Writing the Camera Registers:</b></p>
                <p>The Arduino side of this lab began with establishing communications to the OV7670 camera module. The means of communication was via I2C, that was connected between the two components as depicted below. 
                </p>
                
                <div align = "middle"><img  src="img/arduinoBlock.png" alt=""></div>
                <div align = "middle"><p><small><i>Arduino to Camera Wiring</i></small></p></div>
                
                <p>Once the communications channel was established, the task at hand was to write the appropriate registers on the OV7670 platform to allow for the camera bar testing. After reviewing the datasheet the following register writing was determined to be appropriate.</p>
                
                <div align = "middle"><img  src="img/cameraRegisterWrites.png" alt=""></div>
                <div align = "middle"><p><small><i>Registers Written on Left and Values on Right </i></small></p></div>
                
                <p>Once we had the values and destination, the Arduino needed to actually write these to the camera. The means of register writing was to call one of the provided functions with the register address and desired value:  In order to ensure that the correct values were written to each register, the values are first read at the beginning of operation and displayed on the serial terminal, and then read at the end of operation and displayed on the same terminal. The results of the writing as displayed on the serial terminal can be seen in the following image, exhibiting that each register was updated to the correct values intended by our implementation.</p>
                
                
                <div align = "middle"><img  src="img/serialTerm.jpg" alt=""></div>
                <div align = "middle"><p><small><i>Registers Written on Left and Values on Right </i></small></p></div>
                
                <p> <b>FPGA Communication:</b></p>
                <p> The final aspect of implementation was to create a communication protocol between the Arduino and the FPGA. The general outline of the protocol we developed was a simplistic 5 line parallel communication, one for whether or not a shape was detected (1), one for each shape (4 total), and one for if the color is red or not (5 total) . However, for the lab only two of the lines were necessary: treasure presence and color determination. The FPGAâ€™s pins for these outputs were then wired to two digital pins on the Arduino. Due to random noise, the read could not be done a single time as there was a chance that the read value would be erroneous, thus a different measurement method was devised. Each pin would be read one thousand times, and if the read value was high for greater than 500 of those reads, it was returned as high (nonzero). If not then it was returned as low (0). The function that implemented this can be seen below.</p>
                
                
                <div align = "middle"><img  src="img/serialTerm.jpg" alt=""></div>
                <div align = "middle"><p><small><i>Registers Written on Left and Values on Right </i></small></p></div>
                         
               
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>


    <footer class="footer text-faded text-center py-5">
      <div class="container">
        <p class="m-0 small">Copyright &copy; Your Website 2018</p>
      </div>
    </footer>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  </body>

  <!-- Script to highlight the active date in the hours list -->


</html>
